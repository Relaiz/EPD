using System;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using Avalonia.Controls.Shapes;
using Microsoft.EntityFrameworkCore;
using TeacherScheduleApp.Data;
using TeacherScheduleApp.Helpers;
using TeacherScheduleApp.Models;

namespace TeacherScheduleApp.Services
{
    public class EventService
    {
        public void CreateEvent(Event ev)
        {
            using var db = new AppDbContext();
            db.Events.Add(ev);
            db.SaveChanges();
        }

        public List<Event> GetAllEvents()
        {
            using var db = new AppDbContext();
            return db.Events.ToList();
        }

        public List<Event> LoadEvents()
        {
            using (var context = new AppDbContext())
            {
                return context.Events
                              .Where(e => !e.IsDeleted)
                              .ToList();
            }
        }

        public Event GetEventById(int id)
        {
            using var db = new AppDbContext();
            return db.Events.Find(id);
        }

        public void UpdateEvent(Event ev)
        {
            using var db = new AppDbContext();

            var existing = db.Events
                             .SingleOrDefault(x => x.Id == ev.Id)
                         ?? throw new InvalidOperationException($"Evens Id={ev.Id} nenalezen.");

            existing.Title = ev.Title;
            existing.StartTime = ev.StartTime;
            existing.EndTime = ev.EndTime;
            existing.AllDay = ev.AllDay;
            existing.Description = ev.Description;
            existing.IsDeleted = ev.IsDeleted;
            existing.EventType = ev.EventType;
            existing.ArrivalTime = ev.ArrivalTime;
            existing.DepartureTime = ev.DepartureTime;
            existing.LunchStart = ev.LunchStart;
            existing.LunchEnd = ev.LunchEnd;
            existing.IsAutoGenerated = ev.IsAutoGenerated;
            existing.HasCollision = ev.HasCollision;
            existing.AutoGeneratedForDate = ev.AutoGeneratedForDate;
            db.SaveChanges();
        }

        public void DeleteEvent(int id)
        {
            using (var db = new AppDbContext())
            {
                var ev = db.Events.FirstOrDefault(e => e.Id == id);
                if (ev != null)
                {
                    ev.IsDeleted = true;
                    db.SaveChanges();
                }
            }
        }

        public List<Event> GetEventsForDay(DateTime date)
        {
            using var db = new AppDbContext();
            DateTime dayStart = date.Date;
            DateTime dayEnd = dayStart.AddDays(1);
            return db.Events
                     .Where(e => e.StartTime < dayEnd && e.EndTime > dayStart && !e.IsDeleted)
                     .OrderBy(e => e.StartTime)
                     .ToList();
        }

        public List<Event> GetEventsForWeek(DateTime anyDate)
        {
            var date = anyDate.Date;
            int delta = (int)date.DayOfWeek - (int)DayOfWeek.Monday;
            if (delta < 0) delta += 7;       
            var weekStart = date.AddDays(-delta);

            var weekEnd = weekStart.AddDays(7); 

           
            using var db = new AppDbContext();
            return db.Events
                     .Where(e =>
                         !e.IsDeleted &&
                         e.StartTime < weekEnd &&
                         e.EndTime >= weekStart)
                     .OrderBy(e => e.StartTime)
                     .ToList();
        }


        public List<Event> GetEventsForMonth(DateTime date)
        {
            using var db = new AppDbContext();
            var year = date.Year;
            var month = date.Month;
            return db.Events
                     .Where(e =>
                         e.StartTime.Year == year &&
                         e.StartTime.Month == month &&
                         !e.IsDeleted)
                     .OrderBy(e => e.StartTime)
                     .ToList();
        }
        public List<Event> GetEventsForRange(DateTime start, DateTime end)
        {
            using var db = new AppDbContext();
            return db.Events
                     .Where(e => e.StartTime < end && e.EndTime >= start && !e.IsDeleted)
                     .OrderBy(e => e.StartTime)
                     .ToList();
        }
        public Event? FindEventByStartTime(DateTime startTime)
        {
            using var db = new AppDbContext();
            return db.Events.FirstOrDefault(e => e.StartTime == startTime && !e.IsDeleted);
        }


        
        public void RemoveAutoGeneratedEvents(DateTime date)
        {
            using var db = new AppDbContext();
            var evs = db.Events
                .Where(e => e.IsAutoGenerated && e.AutoGeneratedForDate == date.Date)
                .ToList();
            foreach (var e in evs)
                db.Events.Remove(e);
            db.SaveChanges();
        }

       
        public void CreateEventsBulk(IEnumerable<Event> events, DateTime day)
        {
            using var db = new AppDbContext();
            db.Events.AddRange(events);
            db.SaveChanges();
        }

       
        public List<Event> GetAutoEventsForDay(DateTime date)
            => GetEventsForDay(date)
               .Where(e => e.IsAutoGenerated && e.AutoGeneratedForDate == date.Date)
               .ToList();

    
        public void BalanceEventsForMonth(int year, int month)
        {
            var allEvents = GetEventsForMonth(new DateTime(year, month, 1)).ToList();
            var eventsByDay = allEvents
                .GroupBy(e => e.StartTime.Day)
                .ToDictionary(g => g.Key, g => g.ToList());

            var stats = new List<DayStat>();
            int daysInMonth = DateTime.DaysInMonth(year, month);

            for (int d = 1; d <= daysInMonth; d++)
            {
                var date = new DateTime(year, month, d);
                if (date.DayOfWeek is DayOfWeek.Saturday or DayOfWeek.Sunday ||
                    HolidayHelper.IsCzechHoliday(date))
                    continue;

                stats.Add(new DayStat
                {
                    Date = date,
                    Events = eventsByDay.GetValueOrDefault(d) ?? new List<Event>()
                });
            }

            BalanceDays(stats);

            foreach (var stat in stats.Where(s => !s.IsFixed))
            {
                var allWorks = stat.Events
                    .Where(e => e.EventType != EventType.Lunch)
                    .OrderBy(e => e.StartTime)
                    .ToList();
                var allLunches = stat.Events
                    .Where(e => e.EventType == EventType.Lunch)
                    .OrderBy(e => e.StartTime)
                    .ToList();

                if (allWorks.Any())
                {
                    var arr = allWorks.First().StartTime.TimeOfDay;
                    var lastWorkEnd = allWorks.Last().EndTime.TimeOfDay;
                    var lunchStart = allLunches.FirstOrDefault()?.StartTime.TimeOfDay ?? TimeSpan.Zero;
                    var lunchEnd = allLunches.FirstOrDefault()?.EndTime.TimeOfDay ?? TimeSpan.Zero;
                    var dep = lastWorkEnd;
                    if (allLunches.Any() && lunchEnd > dep)
                    {
                        dep = lunchEnd;
                    }

                    SettingsService.SaveUserSettingsForDate(stat.Date, arr, dep, lunchStart, lunchEnd);
                }

                foreach (var ev in stat.Events)
                {
                    UpdateEvent(ev);
                }
            }
        }

        private bool GetGlobalDefaults(DayOfWeek dow,
            out TimeSpan arr, out TimeSpan dep,
            out TimeSpan lunchStart, out TimeSpan lunchEnd)
        {
            var sem = GlobalSettingsService.GetSemesterForDate(DateTime.Today);
            var gl = GlobalSettingsService.LoadGlobalSettings(sem);
            if (gl == null)
            {
                arr = dep = lunchStart = lunchEnd = TimeSpan.Zero;
                return false;
            }

            (arr, dep, lunchStart, lunchEnd) =
                PdfService.GetWeekdayDefaults(gl, dow);
            return true;
        }

        class DayStat
        {
            public DateTime Date;
            public List<Event> Events;
            public double Worked;
            public double Expected;
            public bool IsFixed;   
        }
        private bool IsFullSpecialDay(DayStat stat, GlobalSettings g)
        {
            var only = stat.Events
                          .Where(e => e.EventType != EventType.Work
                                   && e.EventType != EventType.Lunch)
                          .ToList();
            if (only.Count != 1)
                return false;

            var (arr, dep, _, _) = PdfService.GetWeekdayDefaults(g, stat.Date.DayOfWeek);

            var e = only[0];
            return e.StartTime.TimeOfDay <= arr
                && e.EndTime.TimeOfDay >= dep;
        }
        private class BalanceItem
        {
            public DayStat Stat { get; set; }
            public double Amount { get; set; }
        }

        private void BalanceDays(List<DayStat> days)
        {
            var sem = GlobalSettingsService.GetSemesterForDate(DateTime.Today);
            var glob = GlobalSettingsService.LoadGlobalSettings(sem)
                       ?? GlobalSettingsService.GetDefaultSettings(sem);

            TimeSpan globalStart = TimeSpan.Parse(glob.GlobalStartTime, CultureInfo.InvariantCulture);
            TimeSpan globalEnd = TimeSpan.Parse(glob.GlobalEndTime, CultureInfo.InvariantCulture);
        
            var ( _,  _,   lunchStartMon,  lunchEndMon)=PdfService.GetWeekdayDefaults(glob, DayOfWeek.Monday);

            double baseDayLength = (globalEnd - globalStart).TotalHours;
            double baseLunchLength = (lunchEndMon - lunchStartMon).TotalHours;

            foreach (var stat in days)
            {
                var us = SettingsService.GetUserSettingsForDate(stat.Date);
                TimeSpan arr, dep, ls, le;
                if (us != null)
                {
                    arr = us.ArrivalTime;
                    dep = us.DepartureTime;
                    ls = us.LunchStart;
                    le = us.LunchEnd;
                }
                else
                {
                  (  arr,  dep,  ls,  le )= PdfService.GetWeekdayDefaults(glob, stat.Date.DayOfWeek);
                }

                var special = stat.Events
                    .Where(e => e.EventType != EventType.Work && e.EventType != EventType.Lunch)
                    .Select(e => (e.StartTime, e.EndTime));
                var specialMerged = MergeIntervals(special);
                double specialHours = specialMerged.Sum(iv => (iv.end - iv.start).TotalHours);

                stat.Expected = Math.Max(0, baseDayLength - baseLunchLength - specialHours);

                DateTime workWindowStart = stat.Date + arr;
                DateTime workWindowEnd = stat.Date + dep;
                var workIntervals = stat.Events
                    .Where(e => e.EventType == EventType.Work || e.EventType == EventType.BusinessTrip)
                    .Select(e => (
                        Start: e.StartTime < workWindowStart ? workWindowStart : e.StartTime,
                        End: e.EndTime > workWindowEnd ? workWindowEnd : e.EndTime));
                var mergedWork = MergeIntervals(workIntervals);
                stat.Worked = mergedWork.Sum(iv => (iv.end - iv.start).TotalHours);

            }

            var items = days.Where(d => !d.IsFixed)
                              .Select(d => new BalanceItem { Stat = d, Amount = d.Worked - d.Expected })
                              .ToList();
            var deficits = items.Where(x => x.Amount < 0).ToList();
            var excesses = items.Where(x => x.Amount > 0).ToList();
            foreach (var def in deficits)
            {
                double need = -def.Amount;
                foreach (var ex in excesses.Where(x => x.Amount > 0))
                {
                    double take = Math.Min(ex.Amount, need);
                    if (take <= 0) continue;
                    TimeSpan delta = TimeSpan.FromHours(take);

                    var donor = ex.Stat.Events
                        .Where(e => e.EventType == EventType.Work)
                        .OrderByDescending(e => e.EndTime)
                        .FirstOrDefault();
                    if (donor != null)
                    {
                        DateTime minEnd = donor.StartTime;
                        donor.EndTime = Max(donor.EndTime - delta, minEnd);
                    }

                    var gap = FindGap(def.Stat, take, globalStart, globalEnd);
                    var rec = def.Stat.Events
                        .Where(e => e.EventType == EventType.Work)
                        .OrderByDescending(e => e.EndTime)
                        .FirstOrDefault();
                    if (rec == null)
                    {
                        rec = new Event
                        {
                            Title = "Přenos z jiného dne",
                            EventType = EventType.Work,
                            StartTime = gap.start,
                            EndTime = gap.end,
                            IsAutoGenerated = true,
                            AutoGeneratedForDate = def.Stat.Date
                        };
                        CreateEvent(rec);
                        def.Stat.Events.Add(rec);
                        TimeSpan stdLunchLen = lunchEndMon - lunchStartMon; 
                        var occupied = def.Stat.Events
                            .Where(e => e.EventType != EventType.Lunch)
                            .Select(e => (e.StartTime, e.EndTime))
                            .OrderBy(iv => iv.StartTime)
                            .ToList();

                        DateTime cursor = def.Stat.Date + globalStart;
                        DateTime windowEnd = def.Stat.Date + globalEnd;
                        (DateTime ls, DateTime le) lunchSlot = (default, default);

                        foreach (var iv in occupied)
                        {
                            if ((iv.StartTime - cursor) >= stdLunchLen)
                            {
                                lunchSlot = (cursor, cursor + stdLunchLen);
                                break;
                            }
                            if (iv.EndTime > cursor)
                                cursor = iv.EndTime;
                        }
                        if (lunchSlot == (default, default)
                            && windowEnd - cursor >= stdLunchLen)
                        {
                            lunchSlot = (cursor, cursor + stdLunchLen);
                        }

                        if (lunchSlot != (default, default))
                        {
                            var evLunch = GetEventsForDay(def.Stat.Date);
                            var lunchExists = evLunch.Where(e => e.EventType == EventType.Lunch
                                       && e.StartTime == e.EndTime).Select(e => (e.Id)).ToList();
                            foreach (var item in lunchExists)
                            {
                                DeleteEvent(item);
                            }
                            var lunch = new Event
                            {
                                Title = "Oběd (auto)",
                                EventType = EventType.Lunch,
                                StartTime = lunchSlot.ls,
                                EndTime = lunchSlot.le,
                                IsAutoGenerated = true,
                                AutoGeneratedForDate = def.Stat.Date
                            };
                            CreateEvent(lunch);
                            def.Stat.Events.Add(lunch);
                        }
                    }
                    else
                    {
                        DateTime maxEnd = def.Stat.Date + globalEnd;
                        var oldEnd = rec.EndTime;
                        rec.EndTime = Min(rec.EndTime + delta, maxEnd);
                    }

                    ex.Amount -= take;
                    need -= take;
                    if (need <= 0) break;
                }
            }
        }
        static DateTime Min(DateTime a, DateTime b) => a < b ? a : b;
        static DateTime Max(DateTime a, DateTime b) => a > b ? a : b;
        private List<(DateTime start, DateTime end)> MergeIntervals(IEnumerable<(DateTime start, DateTime end)> intervals)
        {
            var sorted = intervals.OrderBy(x => x.start).ToList();
            var merged = new List<(DateTime start, DateTime end)>();
            foreach (var seg in sorted)
            {
                if (!merged.Any() || merged.Last().end < seg.start)
                    merged.Add(seg);
                else
                    merged[^1] = (
                        merged.Last().start,
                        merged.Last().end > seg.end ? merged.Last().end : seg.end
                    );
            }
            return merged;
        }

        private (DateTime start, DateTime end) FindGap(DayStat stat, double hours,TimeSpan globalStart, TimeSpan globalEnd)
        {
            var occupied = stat.Events
                .Select(e => (e.StartTime, e.EndTime))
                .OrderBy(iv => iv.StartTime)
                .ToList();

            DateTime cursor = stat.Date + globalStart;
            DateTime windowEnd = stat.Date + globalEnd;

            foreach (var iv in occupied)
            {
                if ((iv.StartTime - cursor).TotalHours >= hours)
                    return (cursor, cursor.AddHours(hours));

                if (iv.EndTime > cursor)
                    cursor = iv.EndTime;
            }

            if ((windowEnd - cursor).TotalHours >= hours)
                return (cursor, cursor.AddHours(hours));

            throw new InvalidOperationException(
                $"Žádné volné místo na {hours:F2}h v {stat.Date:yyyy-MM-dd}");
        }
    }
}

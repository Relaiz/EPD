using System;
using System.Collections.Generic;
using System.Linq;
using Microsoft.EntityFrameworkCore;
using TeacherScheduleApp.Data;
using TeacherScheduleApp.Helpers;
using TeacherScheduleApp.Models;

namespace TeacherScheduleApp.Services
{
    public class EventService
    {
        public void CreateEvent(Event ev)
        {
            using var db = new AppDbContext();
            db.Events.Add(ev);
            db.SaveChanges();
        }

        public List<Event> GetAllEvents()
        {
            using var db = new AppDbContext();
            return db.Events.ToList();
        }

        public List<Event> LoadEvents()
        {
            using (var context = new AppDbContext())
            {
                return context.Events
                              .Where(e => !e.IsDeleted)
                              .ToList();
            }
        }

        public Event GetEventById(int id)
        {
            using var db = new AppDbContext();
            return db.Events.Find(id);
        }

        public void UpdateEvent(Event ev)
        {
            using var db = new AppDbContext();

            var existing = db.Events
                             .SingleOrDefault(x => x.Id == ev.Id)
                         ?? throw new InvalidOperationException($"Evens Id={ev.Id} nenalezen.");

            existing.Title = ev.Title;
            existing.StartTime = ev.StartTime;
            existing.EndTime = ev.EndTime;
            existing.AllDay = ev.AllDay;
            existing.Description = ev.Description;
            existing.IsDeleted = ev.IsDeleted;
            existing.EventType = ev.EventType;
            existing.ArrivalTime = ev.ArrivalTime;
            existing.DepartureTime = ev.DepartureTime;
            existing.LunchStart = ev.LunchStart;
            existing.LunchEnd = ev.LunchEnd;
            existing.IsAutoGenerated = ev.IsAutoGenerated;
            existing.HasCollision = ev.HasCollision;
            existing.AutoGeneratedForDate = ev.AutoGeneratedForDate;
            db.SaveChanges();
        }

        public void DeleteEvent(int id)
        {
            using (var db = new AppDbContext())
            {
                var ev = db.Events.FirstOrDefault(e => e.Id == id);
                if (ev != null)
                {
                    ev.IsDeleted = true;
                    db.SaveChanges();
                }
            }
        }

        public List<Event> GetEventsForDay(DateTime date)
        {
            using var db = new AppDbContext();
            DateTime dayStart = date.Date;
            DateTime dayEnd = dayStart.AddDays(1);
            return db.Events
                     .Where(e => e.StartTime < dayEnd && e.EndTime > dayStart && !e.IsDeleted)
                     .OrderBy(e => e.StartTime)
                     .ToList();
        }

        public List<Event> GetEventsForWeek(DateTime anyDate)
        {
            var date = anyDate.Date;
            int delta = (int)date.DayOfWeek - (int)DayOfWeek.Monday;
            if (delta < 0) delta += 7;       
            var weekStart = date.AddDays(-delta);

            var weekEnd = weekStart.AddDays(7); 

           
            using var db = new AppDbContext();
            return db.Events
                     .Where(e =>
                         !e.IsDeleted &&
                         e.StartTime < weekEnd &&
                         e.EndTime >= weekStart)
                     .OrderBy(e => e.StartTime)
                     .ToList();
        }


        public List<Event> GetEventsForMonth(DateTime date)
        {
            using var db = new AppDbContext();
            var year = date.Year;
            var month = date.Month;
            return db.Events
                     .Where(e =>
                         e.StartTime.Year == year &&
                         e.StartTime.Month == month &&
                         !e.IsDeleted)
                     .OrderBy(e => e.StartTime)
                     .ToList();
        }
        public List<Event> GetEventsForRange(DateTime start, DateTime end)
        {
            using var db = new AppDbContext();
            return db.Events
                     .Where(e => e.StartTime < end && e.EndTime >= start && !e.IsDeleted)
                     .OrderBy(e => e.StartTime)
                     .ToList();
        }
        public Event? FindEventByStartTime(DateTime startTime)
        {
            using var db = new AppDbContext();
            return db.Events.FirstOrDefault(e => e.StartTime == startTime && !e.IsDeleted);
        }


        
        public void RemoveAutoGeneratedEvents(DateTime date)
        {
            using var db = new AppDbContext();
            var evs = db.Events
                .Where(e => e.IsAutoGenerated && e.AutoGeneratedForDate == date.Date)
                .ToList();
            foreach (var e in evs)
                db.Events.Remove(e);
            db.SaveChanges();
        }

       
        public void CreateEventsBulk(IEnumerable<Event> events, DateTime day)
        {
            using var db = new AppDbContext();
            db.Events.AddRange(events);
            db.SaveChanges();
        }

       
        public List<Event> GetAutoEventsForDay(DateTime date)
            => GetEventsForDay(date)
               .Where(e => e.IsAutoGenerated && e.AutoGeneratedForDate == date.Date)
               .ToList();

    
        public void BalanceEventsForMonth(int year, int month)
        {
            var allEvents = GetEventsForMonth(new DateTime(year, month, 1)).ToList();

            var eventsByDay = allEvents
                .GroupBy(e => e.StartTime.Day)
                .ToDictionary(g => g.Key, g => g.ToList());

            var stats = new List<DayStat>();
            int daysInMonth = DateTime.DaysInMonth(year, month);

            for (int d = 1; d <= daysInMonth; d++)
            {
                var date = new DateTime(year, month, d);
                if (date.DayOfWeek is DayOfWeek.Saturday or DayOfWeek.Sunday ||
                    HolidayHelper.IsCzechHoliday(date))
                    continue;

                stats.Add(new DayStat
                {
                    Date = date,
                    Events = eventsByDay.GetValueOrDefault(d) ?? new List<Event>()
                });
            }

            BalanceDays(stats);

            foreach (var stat in stats.Where(s => !s.IsFixed))
            {
                var works = stat.Events
                    .Where(e => e.EventType == EventType.Work)
                    .OrderBy(e => e.StartTime)
                    .ToList();
                var lunches = stat.Events
                    .Where(e => e.EventType == EventType.Lunch)
                    .OrderBy(e => e.StartTime)
                    .ToList();

                if (works.Any())
                {
                    var newArr = works.First().StartTime.TimeOfDay;
                    var newDep = works.Last().EndTime.TimeOfDay;
                    var newLs = lunches.FirstOrDefault()?.StartTime.TimeOfDay ?? TimeSpan.Zero;
                    var newLe = lunches.FirstOrDefault()?.EndTime.TimeOfDay ?? TimeSpan.Zero;

                    SettingsService.SaveUserSettingsForDate(
                        stat.Date, newArr, newDep, newLs, newLe);
                }

                foreach (var ev in stat.Events)
                    UpdateEvent(ev);
            }
        }

        private bool GetGlobalDefaults(DayOfWeek dow,
            out TimeSpan arr, out TimeSpan dep,
            out TimeSpan lunchStart, out TimeSpan lunchEnd)
        {
            var sem = GlobalSettingsService.GetSemesterForDate(DateTime.Today);
            var gl = GlobalSettingsService.LoadGlobalSettings(sem);
            if (gl == null)
            {
                arr = dep = lunchStart = lunchEnd = TimeSpan.Zero;
                return false;
            }

            (arr, dep, lunchStart, lunchEnd) =
                PdfService.GetWeekdayDefaults(gl, dow);
            return true;
        }

        class DayStat
        {
            public DateTime Date;
            public List<Event> Events;
            public double Worked;    
            public bool IsFixed;   
        }
        private bool IsFullSpecialDay(DayStat stat, GlobalSettings g)
        {
            var only = stat.Events
                          .Where(e => e.EventType != EventType.Work
                                   && e.EventType != EventType.Lunch)
                          .ToList();
            if (only.Count != 1)
                return false;

            var (arr, dep, _, _) = PdfService.GetWeekdayDefaults(g, stat.Date.DayOfWeek);

            var e = only[0];
            return e.StartTime.TimeOfDay <= arr
                && e.EndTime.TimeOfDay >= dep;
        }
        private class BalanceItem
        {
            public DayStat Stat { get; set; }
            public double Amount { get; set; }
        }

        private void BalanceDays(List<DayStat> days)
        {
            var sem = GlobalSettingsService.GetSemesterForDate(DateTime.Today);
            var g = GlobalSettingsService.LoadGlobalSettings(sem)
                   ?? GlobalSettingsService.GetDefaultSettings(sem);
            var baselineInfo = new Dictionary<DateTime, (TimeSpan arr, TimeSpan dep, TimeSpan ls, TimeSpan le)>();

            foreach (var stat in days)
            {
                var us = SettingsService.GetUserSettingsForDate(stat.Date);
                TimeSpan arr, dep, ls, le;

                if (us != null)
                {
                    arr = us.ArrivalTime;
                    dep = us.DepartureTime;
                    ls = us.LunchStart;
                    le = us.LunchEnd;
                }
                else
                {
                    (arr, dep, ls, le) = PdfService.GetWeekdayDefaults(g, stat.Date.DayOfWeek);
                    
                }

                baselineInfo[stat.Date] = (arr, dep, ls, le);

                if (IsFullSpecialDay(stat, g))
                {
                    stat.IsFixed = true;
                    var only = stat.Events.First(e => e.EventType != EventType.Work && e.EventType != EventType.Lunch);
                    stat.Worked = (only.EndTime - only.StartTime).TotalHours;
                }
                else
                {
                    stat.IsFixed = false;
                    stat.Worked = stat.Events
                        .Where(e => e.EventType == EventType.Work || e.EventType == EventType.BusinessTrip)
                        .Sum(e => (e.EndTime - e.StartTime).TotalHours);
                }

                var expected = (dep - arr - (le - ls)).TotalHours;
            }

            var items = days
             .Where(d => !d.IsFixed)
             .Select(d =>
             {
                 var (gArr, gDep, gLs, gLe) =
                     PdfService.GetWeekdayDefaults(g, d.Date.DayOfWeek);
                 var globalExpected = (gDep - gArr - (gLe - gLs)).TotalHours;
                 return new BalanceItem
                 {
                     Stat = d,
                     Amount = d.Worked - globalExpected
                 };
             })
             .ToList();

            var deficits = items.Where(x => x.Amount < 0).ToList();
            var excesses = items.Where(x => x.Amount > 0).ToList();
            foreach (var def in deficits)
            {
                double need = -def.Amount;

                foreach (var ex in excesses.Where(e => e.Amount > 0))
                {
                    double take = Math.Min(ex.Amount, need);
                    if (take <= 0) continue;
                    var delta = TimeSpan.FromHours(take);

                    // donor
                    var lastEx = ex.Stat.Events
                                 .Where(e => e.EventType == EventType.Work)
                                 .OrderByDescending(e => e.EndTime)
                                 .FirstOrDefault();
                    if (lastEx != null)
                    {
                        var oldEnd = lastEx.EndTime;
                        lastEx.EndTime -= delta;
                    }

                    // recipient
                    var lastDef = def.Stat.Events
                                  .Where(e => e.EventType == EventType.Work)
                                  .OrderByDescending(e => e.EndTime)
                                  .FirstOrDefault();
                    if (lastDef != null)
                    {
                        var oldEnd = lastDef.EndTime;
                        lastDef.EndTime += delta;
                       
                    }

                    ex.Amount -= take;
                    need -= take;                  
                    if (need <= 0) break;
                }
            }
        }
    }
}
